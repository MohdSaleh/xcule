"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdapterBase = exports.VALIDATED = void 0;
const query_1 = require("./query");
exports.VALIDATED = Symbol.for('@feathersjs/adapter/sanitized');
const alwaysMulti = {
    find: true,
    get: false,
    update: false
};
/**
 * An abstract base class that a database adapter can extend from to implement the
 * `__find`, `__get`, `__update`, `__patch` and `__remove` methods.
 */
class AdapterBase {
    constructor(options) {
        this.options = {
            id: 'id',
            events: [],
            paginate: false,
            multi: false,
            filters: {},
            operators: [],
            ...options
        };
    }
    get id() {
        return this.options.id;
    }
    get events() {
        return this.options.events;
    }
    /**
     * Check if this adapter allows multiple updates for a method.
     * @param method The method name to check.
     * @param params The service call params.
     * @returns Wether or not multiple updates are allowed.
     */
    allowsMulti(method, params = {}) {
        const always = alwaysMulti[method];
        if (typeof always !== 'undefined') {
            return always;
        }
        const { multi } = this.getOptions(params);
        if (multi === true || !multi) {
            return multi;
        }
        return multi.includes(method);
    }
    /**
     * Returns the combined options for a service call. Options will be merged
     * with `this.options` and `params.adapter` for dynamic overrides.
     *
     * @param params The parameters for the service method call
     * @returns The actual options for this call
     */
    getOptions(params) {
        const paginate = params.paginate !== undefined ? params.paginate : this.options.paginate;
        return {
            ...this.options,
            paginate,
            ...params.adapter
        };
    }
    /**
     * Returns a sanitized version of `params.query`, converting filter values
     * (like $limit and $skip) into the expected type. Will throw an error if
     * a `$` prefixed filter or operator value that is not allowed in `filters`
     * or `operators` is encountered.
     *
     * @param params The service call parameter.
     * @returns A new object containing the sanitized query.
     */
    async sanitizeQuery(params = {}) {
        // We don't need legacy query sanitisation if the query has been validated by a schema already
        if (params.query && params.query[exports.VALIDATED]) {
            return params.query || {};
        }
        const options = this.getOptions(params);
        const { query, filters } = (0, query_1.filterQuery)(params.query, options);
        return {
            ...filters,
            ...query
        };
    }
}
exports.AdapterBase = AdapterBase;
//# sourceMappingURL=service.js.map